
- 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴이다.
- 디자인 패턴을 참고하여 개발할 경우 개발의 효율성과 유지 보수성이 높아지며, 프로그램의 최적화에 도움이 된다.

### 유형

생성 - 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
구조 - 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
행위 - 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴

## <span style="background:#d4b106">생성 패턴</span>

생(빌 프로 팩 앱 싱)
- Builder
	- 복잡한 객체의 생성 과정을 여러 단계로 나누어 처리한다
	- 최종적으로 다양한 표현을 갖는 객체를 생성할 수 있도록 한다.
	- 객체의 생성이 복잡할 때 사용되며, 코드의 유지보수성과 확장성을 향상시키는 데 유용하다.
- Prototype
	- 기존 객체를 복제함으로써 새로운 객체를 생성한다.
	- Prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.
- Factory Method
	- 객체 생성을 처리하는 인터페이스를 제공하고, 실제 객체의 생성은 서브클래스가 결정하도록 위임한다.
	- 객체 생성에 대한 의존성을 줄이고, 확장성과 유연성을 향상시킬 수 있다.
	- 객체를 생성하는 처리를 파생 클래스로 분리하여 처리하도록 캡슐화 한다.
	- Virtual - Constructor 패턴이라고도 한다.
- Abstract Factory
	- 서로 관련된 객체들의 패밀리를 생성하기 위해 인터페이스를 제공
	- 구체적인 클래스를 명시하지 않고도 객체들을 생성할 수 있다
	- 동일한 주제의 다른 팩토리를 묶음
- Singleton
	- 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴
	- 한 클래스에 한 객체만 존재하도록 제한


## <span style="background:#b1ffff">구조 패턴</span>

구(브데 퍼플 프록 컴 어)
- Bridge
	- <span style="background:#d4b106">추상화와 구현을 분리</span>하여 두 계층이 독립적으로 변화할 수 있게 한다.
	- 두 개의 클래스 계층을 분리해 두면 각가의 클래스 계층을 독립적으로 확장할 수 있다.
- Decorator
	- 객체에 동적으로 새로운 기능을 추가한다.
	- 코드의 수정 없이 객체의 기능을 확장할 수 있는 방법을 제공한다.
	- 상속을 사용하지 않고도 객체의 기능을 동적으로 확장할 수 있도록 해준다.
	- <span style="background:#d4b106">객체의 결합을 통해 기능을 동적으로 유연하게 확장</span>
- Facade
	- 복잡한 시스템을 <span style="background:#d4b106">단순화</span>하는 디자인 패턴
	- 클라이언트는 단일 인터페이스만 사용하고 내부 구현은 숨긴다
	- 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴이다
	- <span style="background:#d4b106">통합된 인터페이스 제공</span>
- Flyweight
	- 객체를 공유하여 메모리를 절약한다.
	- 객체 생성 시간이 오래걸리는 경우, 또는 객체가 많이 생성될 가능성이 있는 경우에 사용된다.
	- 여러개의 가상 인스턴스를 제공하여 메모리 절감
- Proxy
	- <span style="background:#d4b106">다른 객체에 대한 접근 제어/중개</span> 하는 디자인 패턴
	- 특정 객체의 대리자나 대변인 역할을 하는 프록시 객체를 제공한다
	- 특정 객체로의 접근을 제어하기 위한 용도로 사용
- Composite
	- 객체를 <span style="background:#d4b106">트리 구조로 구성</span>하여 개별 객체와 객체의 조합을 클라이언트에서 동일하게 처리할 수 있도록 한다.
-  Adapter
	- 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있도록 한다
	- 클라이언트에서 요구하는 다른 인터페이스로 변환한다
	- 한 클래스의 인터페이스를 클라이언트에서 필요로 하는 인터페이스로 변환해준다

## 행위 패턴

행(미인이 템옵 스테 비커 스트 메체)

- Mediator
	- 여러 객체 간의 상호작용을 중앙 집중식으로 관리한다.
	- 객체간의 통제와 지시의 역할을 하는<span style="background:#d4b106"> 중재자를 두어</span> 객체지향의 목표를 달성한다.
	- 여러 객체들이 서로 메시지를 주고받는 상호 작용을 특정 객체 안에 캡슐화하여 서로의 존재를 모르는 상태에서도 메시지를 주고 받으며 협력할 수 있도록 한다.
- Interpreter - 해석
	- <span style="background:#d4b106">문법 규칙</span>을 기반으로 문장을 해석한다
	- 프로그래밍 언어의 문법을 해석하는 데 사용된다.
- Iterator
	- 컬렉션의 요소들을 <span style="background:#d4b106">순차적</span>으로 접근하고 처리할 수 있도록 한다.
	- 집합 객체의 요소들에 대해 순서대로 접근하는 방법을 제공한다.
	- 배열, 배열리스트, 해시테이블과 같은 객체를 처리하는데 사용하는 패턴
- Template-Method
	- 알고리즘의 핵심적인 골격은 그대로 유지하면서, 일부 단계는 하위 클래스에서 구체적으로 구현한다.
- Observer
	- 객체의 상태 변화를 관찰하고 싶은 다른 객체들에게 자동으로 알린다
	- 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대다 의존
- State
	- 객체의 내부 상태에 따라 객체의 동작을 변경한다.
	- 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴
- Visitor
	- 객체의 구조를 변경하지 않고 객체에 새로운 연산을 추가한다.
- Command
	- 요청을 객체로 캡슐화하여 요청자와 처리자를 분리한다.
	- 명령, 요청자, 클라이언트, 수신자로 구분된다.
- Strategy
	- 알고리즘을 객체로 캡슐화하고, 알고리즘을 선택하고 실행하는 방법을 제공한다.
	- GPS 신호를 수신하는 경우와 수신하지 못하는 경우에 따라 차량의 위치를 구하는 다른 알고리즘을 선택하고자 할 때 가장 적합하다.
	- CPU나 메모리와 같은 컴퓨터 부품의 가격은 다양한 이유로 가격 결정 정책이 자주 변경될 수 있다. 이를 위해 가격 결정 정책을 클래스로 캡슐화하여 쉽게 변경 및 추가할 수 있다.
- Memento - 기념품
	- 객체의 이전 상태를 저장하고 복원할 수 있도록 한다.
- Chain of Responsibility
	- 요청을 처리하는 객체들을 체인 형태로 연결하여 요청을 순서대로 전달한다
	- 각 객체는 요청을 처리할 수 있는지 판단하고 , 처리할 수 없으면 다음 객체에 전달한다.