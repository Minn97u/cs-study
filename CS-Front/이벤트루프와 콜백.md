**✏️ 비동기 처리가 필요한 이유**

자바스크립트는 **싱글 스레드 언어**이다. 한 번에 하나만 처리할 수 있는 것이다.

그래서 만약 네트워크 요청이나 DB 쿼리처럼 오래 걸리는 작업이 메인 스레드에서 실행되면, 나머지 작업들이 줄줄이 대기하게 된다.

나는 이게 왜 문제인지 생각해 봤다.
메인 스레드가 막혀 있으면, 사용자 입장에서는 화면이 멈춘 것처럼 느껴질 테니까.

그래서 결국, 메인 스레드를 막지 않고 작업을 진행할 수 있는 방법이 필요했던 것이다.

그게 바로 **비동기 처리**였다.

---

​

✏️ **나는 비동기 작업이 백그라운드에서 일어난다는 걸 알게 되었다.**

자바스크립트는 이런 긴 작업을 메인 스레드에서 직접 처리하지 않는다.

Node.js에서는 **libuv**라는 C++ 라이브러리가, 브라우저에서는 **Web API** 같은 것들이 대신 처리해 준다.

그리고 이걸 “백그라운드 작업”이라고 부른다. 메인 스레드는 할 일만 하고, 무거운 일들은 뒤에서 알아서 처리하는 것이다.

​

> **왜 C++ 라이브러리를 사용하는가?**  
  알고 보니, 자바스크립트 언어 자체는 기본적인 흐름만 다룰 수 있다.  
파일 시스템 접근이나 OS 수준의 작업은 할 수 없었다.  
> 그래서 Node.js나 브라우저 같은 "자바스크립트 실행 환경”은  자바스크립트로는 못하는 기능들을 C++ 같은 걸로 만들어서 제공해 준 것이다.  

> 굳이 비유를 하자면 
> 사람이 혼자 살아도 되지만, TV랑 냉장고가 있으면 훨씬 편한 것처럼.
> 자바스크립트는 사람이고, libuv나 Web API는 가전제품 같은 존재인 것이다.
> 
---

​

✏️ Callback 함수란?

이제 메인 스레드가 비동기 작업을 백그라운드에 맡긴다. 그런데 맡겼으면 결과를 나중에 받아야 할 것이다.

성공했는지 실패했는지 알아야 하니까.
그래서 메인 스레드는 **“비동기 작업이 끝나면 이 함수를 실행해 줘”** 하고 함수를 하나 같이 넘긴다.

그게 바로 **콜백 함수(callback function)**이다.

**비유 :** “내가 이거 맡길게, 끝나면 전화해!” -> 여기서 전화가 콜백 함수

---

​

✏️ 이벤트 루프의 필요성과 동작 원리

콜백 함수는 백그라운드 작업이 끝나야 메인 스레드로 돌아올 수 있다.
그런데 돌아오려는 순간, 메인 스레드가 또 다른 일을 하고 있을 수도 있다.

“지금 들어가도 될까?” 망설이는 콜백 함수들을 위해,
**“언제 들어오세요”** 하고 타이밍을 잡아주는 시스템이 필요한데,

그걸 해주는 게 바로 **이벤트 루프(Event Loop)이다.**

​
**📌 이벤트 루프 흐름 요약**

1. **Call Stack (호출 스택)**: 메인 스레드에서는 모든 함수가 Call Stack이라는 공간에 쌓인다.
-   함수가 호출되면 쌓이고(push), 완료되면 빠진다(pop).
-   비동기 함수는 Call Stack에 들어오자마자 백그라운드로 이동한다.  

    그러는 동안 Call Stack은 다른 함수들을 계속 처리할 수 있다. 그래서 싱글 스레드인데도 멈추지 않고 일할 수 있는 것이다.


```

[ Call Stack ]

 ┌─────────────────────┐

 │  console.log('A')    │ → 실행 후 pop

 │  fetchData()         │ → 비동기 작업, pop하고 백그라운드로

 │  console.log('B')    │ → 실행 후 pop

 └─────────────────────┘

```

-   fetchData() 같은 비동기 함수는 Call Stack에 올라오자마자 바로 백그라운드로 보내진다.
-   메인 스레드는 계속 다음 작업(console.log('B'))을 실행할 수 있다.

​

2. **백그라운드 작업**:
-   libuv나 Web API가 무거운 작업을 처리.

2. **Event Queue (이벤트 큐)**:
-   백그라운드 작업이 끝나면, 콜백 함수는 **Event Queue**에 쌓인다
-   Event Queue는 대기줄 같은 곳이다. (FIFO 구조)

​

```

[ 백그라운드 ]

 ┌─────────────────────┐

 │  fetchData() 처리 중  │

 └─────────────────────┘

​

↓ (작업 완료 시)

​

[ Event Queue ]

 ┌──────────────────────┐

 │  fetchData의 callback │

 └──────────────────────┘

```

-   백그라운드에서 fetchData() 처리가 끝나면,
-   콜백 함수가 Event Queue로 넘어온다.

​

4. **Event Loop**:
-   이벤트 루프는 계속해서 Call Stack을 지켜본다.
-   비어 있으면 Event Queue에서 콜백 함수를 꺼내 Call Stack에 넣어 실행.

```

[ Call Stack ]           [ Event Queue ]

 ┌───────────────┐        ┌──────────────────────┐

 │               │        │  fetchData의 callback │

 └───────────────┘        └──────────────────────┘

    ↑ 비어있다!             (대기 중)

​

=> Event Loop가 Event Queue를 확인하고,

=> fetchData의 callback을 Call Stack으로 옮긴다!

```

-   Call Stack이 비어 있는지 이벤트 루프가 계속 감시한다.
-   비어있으면 Event Queue에서 콜백을 Shift 해서 Stack으로 Push 한다.

​

**Call Stack**은 바로 실행하는 곳,
**Event Queue**는 대기줄,
**Event Loop**는 둘 사이를 조율하는 신호등 같은 존재인 것이다

---

​

**💡 setTimeout 예제**
```

console.log('A');

​

setTimeout(() => {

  console.log('B');

}, 1000);

​

console.log('C');

```
이걸 봤을 때는 A -> C -> (1초 후) B 가 출력될 것이라고 생각은 든다. 그렇지만 어떤 흐름으로 동작하는지는 이해하지 못했는데  

천천히 흐름을 따라가 보면

​

1\. ‘A’가 바로 출력되고, Call Stack에서 빠진다(pop).

```

[ Call Stack ]

 ┌─────────────────────┐

 │ console.log('A')     │ → 실행, A 출력

 └─────────────────────┘

```

​
2\. setTimeout은 백그라운드(Web API)로 넘어가고, 1초 동안 타이머가 돌아간다.

```

[ Call Stack ]

 ┌─────────────────────┐

 │ setTimeout(callback) │ → 백그라운드로 이동

 └─────────────────────┘

​

[ 백그라운드 ]

 ┌──────────────────────────┐

 │ setTimeout 타이머(1초) 작동│

 └──────────────────────────┘

```

​

3\. ‘C’가 출력되고, Call Stack이 **비워진다**.

```

[ Call Stack ]

 ┌─────────────────────┐

 │ console.log('C')     │ → 실행, C 출력

 └─────────────────────┘

```

​

4\. 1초 타이머가 끝나고, 콜백(console.log('B'))이 Event Queue에 쌓인다.

```

[ Event Queue ]

 ┌─────────────────────┐

 │ callback (console.log('B')) │

 └─────────────────────┘

```

​

5\. Event Loop는 Call Stack이 비어 있는 걸 확인한다.
Event Queue에 대기 중이던 콜백을 꺼내서 Call Stack에 올린다.

```

[ Call Stack ]

 ┌──────────────────────┐

 │ callback 실행        │ → console.log('B')

 └──────────────────────┘

```

​

그래서 **‘B’가 1초 후에 출력**되는 것이다!

정리
```

1. A 출력

2. setTimeout 백그라운드로

3. C 출력

4. 1초 후 setTimeout 콜백 Event Queue 등록

5. Call Stack 비어있음 확인

6. Event Queue → Call Stack

7. B 출력

```