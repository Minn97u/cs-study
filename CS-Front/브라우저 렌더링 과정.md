#### 웹 개발을 하다 보면 “렌더링 성능”, “페인팅 최적화”, “Reflow 줄이기” 같은 용어를 자주 접하게 된다.

#### 그런데 실제로 **브라우저가 HTML을 어떻게 화면에 그리는지** 에 대해서 제대로 몰라 이렇게 정리해보려고 한다.

---

**1\. HTML 파싱과 DOM 트리 생성**

브라우저는 서버로부터 HTML 파일을 받으면, 가장 먼저 **파싱(Parser)** 작업을 시작한다.

파싱이란 쉽게 말해 “코드를 한 글자씩 읽어서 의미 있는 구조로 바꾸는 일”이다.

브라우저는 위에서 아래로 HTML 태그들을 읽으며, 이를 트리 구조의 객체(DOM Tree)로 변환한다.

예를 들어, 아래와 같은 HTML이 있다고 한다면

```
<html>
  <body>
    <h1>안녕하세요</h1>
    <p>민규의 블로그에 오신 것을 환영합니다!</p>
  </body>
</html>
```

이 HTML은 다음과 같은 트리 구조(DOM 트리)로 메모리에 저장된다

```
html
└── body
    ├── h1
    └── p
```

이 트리는 웹 페이지의 **구조**를 표현하게 된다.

---

**2\. CSS 파싱과 CSSOM 생성**

HTML 안에는 종종 CSS 스타일이 포함되거나 외부에서 CSS 파일을 가져오기도 한다.

```
<link rel="stylesheet" href="style.css">
```

이때 브라우저는 CSS도 따로 파싱해서 **CSSOM(CSS Object Model)**이라는 또 다른 트리 구조로 만든

CSSOM은 웹 페이지의 **스타일 정보(색상, 폰트, 여백 등)**를 담고 있다.

---

**3\. 렌더 트리(Render Tree) 생성**

이제 브라우저는 **DOM 트리(내용)**와 **CSSOM 트리(스타일)**를 합쳐서

화면에 실제로 그릴 수 있는 **트리(Render Tree)**를 생성한다.

-   display: none 속성이 적용된 요소는 렌더 트리에 포함되지 않는다.
-   visibility: hidden은 포함되지만, 투명하게 처리한다.

렌더 트리는 **화면에 보일 요소들만을 위한 구조**라고 이해하면 된다.

---

**4\. 레이아웃 (Reflow, Layout)**

렌더 트리가 만들어졌다면 이제 각 요소의 **위치(position)**와 **크기(width/height)**를 계산해야한다.

이 과정을 **레이아웃(Layout)** 또는 **리플로우(Reflow)**라고 한다.  
  

> 💡 리플로우와 리페인트에 대해서 알아보기 -> [https://minn97u.tistory.com/21](https://minn97u.tistory.com/21 "리플로우와 피페인트에 대해서 알아보기")

 [\[WEB\] 리플로우와 리페인트

웹 퍼포먼스를 고민할 때, 빠지지 않고 등장하는 개념이 있다. 바로 리플로우(Reflow) 와 리페인트(Repaint) 이다. 화면을 그리는 과정에서 이 두 개념의 차이가 무엇이고 어떻게 최적화 할 수 있을지

minn97u.tistory.com](https://minn97u.tistory.com/21)

```
h1 {
  margin-top: 20px;
  padding: 10px;
  font-size: 24px;
}
```

위 스타일에 따라 h1이 화면 어디에 그려질지 브라우저는 치밀하게 계산하고

이 작업이 페이지 내 모든 요소에 대해 수행된다.

---

**5\. 페인팅 (Repaint, Painting)**

이제 각 요소의 위치가 정해졌다면, 그 요소를 **색상, 글자, 테두리, 그림자** 등 시각적으로 꾸미는 과정이 이루어진다

이 작업이 바로 페인팅(Painting)

-   배경색
-   텍스트 색
-   이미지 삽입
-   박스 테두리

등의 시각적 요소가 실제로 픽셀(pixel) 전환되어 화면에 그려진다.

---

**6\. 컴포지팅 (Compositing)**

웹 페이지는 여러 개의 레이어(layer)로 나뉘어 처리된다.

예를 들어, fixed 요소나 transform을 사용한 요소는 별도의 레이어로 분리한다.

각 레이어는 GPU에 의해 합성(Compositing)되어 하나의 화면으로 완성된다.

---

### **📌 HTML 파싱 중간에 script 태그를 만나면 어떻게 될까?  
  
기술 면접 질문으로 나올 수 있는 가능성이 있다고 해서 정리해보았다  
  

브라우저는 HTML을 **위에서 아래로 한 줄씩** 읽으며 **DOM 트리를 만들기 위해 파싱(parser)**을 한다.

그런데 파싱 도중 <스크립트> 태그를 만나면, 브라우저는 결정을 내리게 된다.

기본적으로 <스크립트> 태그를 만나면:

1.  HTML 파싱을 일시 중단한다
2.  스크립트를 다운로드한다. (외부 스크립트인 경우)
3.  스크립트를 실행.
4.  실행이 끝난 후 HTML 파싱을 재개한다.

**💡 왜 파싱을 멈출까?**

<스크립트> 내부에 **DOM을 조작하거나 문서에 영향을 주는 코드**가 있을 수 있기 때문.

아직 생성되지 않은 DOM을 수정하려고 할 수 있으니,

브라우저는 **안전하게 DOM 파싱을 중단하고, 스크립트 실행이 끝난 후 다시 시작**하는 것!

---

## **async와 defer**

HTML 파싱을 멈추는 건 성능 저하로 이어질 수 있다.

그래서 **비동기 로딩**을 가능하게 하는 속성이 등장하는데  바로 **async와** **defer** 이다.

 **✏️ async**

-   HTML 파싱과 **병렬로 스크립트를 다운로드합니다.**
-   **다운로드가 끝나면 곧바로 실행**, 파싱은 잠시 멈춥니다.
-   따라서 **실행 순서가 보장되지 않음**
-   **독립적인 기능**에 적합 (예: 광고, 분석 스크립트 등)

✏️ defer

-   HTML 파싱과 병렬로 스크립트를 다운로드합니다.
-   파싱이 끝난 후에 실행합니다.
-   스크립트가 여러 개일 경우 순서대로 실행됨
-   초기화 코드나 의존성이 있는 스크립트에 적합

| 속성 | 다운로드 시점 | 실행 시점 | HTML 파싱 차단 | 실행 순서 보장 |
| --- | --- | --- | --- | --- |
| 없음 | 즉시 | 즉시 | ⭕️ | ⭕️ |
| async | 병렬 | 도착 즉시 | ⭕️ | ❌ |
| defer | 병렬 | 파싱 완료 후 | ❌ | ⭕️ |
