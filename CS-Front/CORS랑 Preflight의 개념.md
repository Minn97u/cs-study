웹 개발을 하다 보면 꼭 한 번은 **CORS 에러**를 마주하게 된다.  
도대체 왜 이런 에러가 생기는 건지, 그리고 CORS는 정확히 무엇인지에 대해 정리해보려고 한다.

---

### ✏️ CORS란?

CORS(Cross-Origin Resource Sharing)는 말 그대로 “출처가 다른 곳과 리소스를 주고받을 수 있게 해주는 방법”이다.

왜 이런 규칙이 생겼을까?

**📌 CORS는 SOP(동일 출처 정책)이라는 보안 정책 때문에 등장했다.**

SOP는 “같은 주소에서만 데이터를 주고받을 수 있다”는 규칙인데, 웹 서비스가 복잡해지면서 외부 API나 리소스를 자주 사용하게 되었고, **이런 사용을 허용하기 위한 예외 처리 방법**으로 CORS가 만들어진 것이다.

**비유하자면 SOP는 ‘우리 회사 출입증이 있어야만 출입 가능해!’라는 원칙이고,**

CORS는 ‘이 사람은 다른 회사 사람이지만 특별 허가증이 있으니까 들여보내도 돼’라는 예외 규칙이다.

---

브라우저도 마찬가지다.

기본적으로는 “나랑 같은 회사(같은 출처) 건물에서만 택배를 주고받을 수 있어!”라고 생각한다.

그런데 요즘 서비스들은 프론트와 백엔드가 분리돼 있거나, 외부 API를 사용하는 경우가 많다.

그래서 이제는 서로 다른 건물 간에도 택배를 주고받을 수 있도록

**‘허락받은 경우에만’** 가능하게 만든 규칙이 바로 CORS라고 보면 된다.

-   예를 들어, localhost:3000(프론트)에서 api.naver.com(백엔드)으로 요청을 보내면, 브라우저는 “이건 다른 건물인데 괜찮을까?” 하고 의심한다.
-   이때 백엔드가 응답 헤더에 “응, 이 주소는 택배 받아도 돼!”라고 명시해줘야 비로소 브라우저가 “오케이, 그러면 보내도 되겠다” 하고 CORS 요청을 허용하게 된다.

---

> **SOP(동일 출처 정책)이란?**  
>   
> 비유: 회사 출입증 검사  
>   
> SOP(Same-Origin Policy)는 브라우저가 기본적으로 갖고 있는 보안 원칙이다.  
> “내 회사 출입증으로는 다른 회사 건물엔 못 들어간다!”는 규칙.  
>   
> 이 출입증에는 3가지 정보가 들어 있다:  
> • 도메인 (회사명)  
> • 포트 번호 (출입구 번호)  
> • 프로토콜 (도보인지 택시인지)  
>   
> 이 세 가지가 다 같아야만 출입을 허용하는 것이 SOP. 만약 하나라도 다르면 접근 금지!  
>   
> 이 규칙이 없다면, 다른 사이트에서 우리들의 쿠키나 로그인 정보를 몰래 가져가는 보안 사고가 발생할 수 있다.

---

### **그럼 모든 CORS 요청이 다 같은 방식일까?**

CORS 요청은 크게 **단순 요청**이냐, 아니면 **Preflight 요청이 필요한 민감한 요청**이냐에 따라 다르게 처리된다.

### ✏️  **Preflight 요청이란?**

📦 “이 택배는 위험할 수도 있으니까, 먼저 허락부터 받고 보낼게요!”

어떤 요청은 단순히 데이터를 주고받는 게 아니라, 보안적으로 민감할 수 있다.

예를 들어 PUT, DELETE 같은 메서드를 쓰거나, 커스텀 헤더를 추가하는 경우를 생각할 수 있다.

이럴 땐 브라우저가 먼저 **“이런 요청을 보내도 괜찮을까요?”** 하고

OPTIONS 메서드로 사전 허가 요청을 서버에 보낸다. 이게 바로 Preflight 요청이다.

서버가 “응, 그런 요청 괜찮아~” 하고 허락하면 그때서야 진짜 요청을 보낼 수 있는 것이다.

이 과정을 통해 **서버에 불필요한 민감 요청을 막고, 보안도 챙길 수 있는** 거다.

---

### ✏️  **단순 요청(Simple Request)이란?**

🍞 “이 정도는 그냥 바로 주고받아도 돼~”

반대로, 보안적으로 민감하지 않은 요청은 굳이 허락받지 않아도 된다.

예를 들어:

• 메서드가 GET, HEAD, POST 중 하나일때

• Content-Type이 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나일때

• 특별한 커스텀 헤더가 없는 경우

이런 요청은 브라우저가 “이건 위험하지 않으니까 그냥 바로 보내도 되겠다~” 하고 **Preflight 없이 바로 요청을 보낸다.**

---

**Preflight 요청은 매번 일어날까?**

브라우저는 **서버의 허가 응답을 캐싱**할 수 있다. 응답 헤더에 Access-Control-Max-Age 값이 있으면 그 시간(초 단위) 동안은

**같은 요청에 대해 Preflight를 다시 보내지 않아도 된다.**

즉, 마치 단골 거래처는 매번 확인 안 해도 바로 들여보내주는 느낌이라고 보면 된다.

---

**그럼 CORS 에러는 언제 나는 걸까?**

개발하다 보면 한 번쯤 이런 에러가 뜬다.

"Access to fetch at '[https://api.example.com'](https://api.example.com') from origin 'http://localhost:3000' has been blocked by CORS policy..."

처음 보면 **“분명히 요청 잘 보냈는데 왜 안 되는 거야?”** 싶을 수 있지만 이 에러의 진짜 의미는  
**“브라우저가 요청 보내긴 했는데, 서버에서 허락 안 해줘서 막은거야” 이다.**

즉, 브라우저는 **SOP 규칙**에 따라 다른 출처로 요청을 보낼 때 서버가 CORS 관련 헤더로 명시적으로 허락하지 않으면 요청을 거절해버린다.

**그럼 어떻게 해결해야 할까?**

CORS는 **서버가 허용해줘야** 하는 규칙이기 때문에 해결 방법은 백엔드에서 아래와 같은 헤더를 추가해야한다.

```
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```