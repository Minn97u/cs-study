웹 퍼포먼스를 고민할 때, 빠지지 않고 등장하는 개념이 있다. 

바로 **리플로우(Reflow)** 와 **리페인트(Repaint)** 이다.

화면을 그리는 과정에서 이 두 개념의 차이가 무엇이고 어떻게 최적화 할 수 있을지 정리해보려고 한다.

---

**✏️ 리플로우란 무엇인가?**

리플로우는 브라우저가 **레이아웃을 다시 계산**하는 과정을 의미한다.

예를 들어, DOM 요소의 width, height, margin, padding, position, display 등을 변경하거나 접근할 때 리플로우가 발생한다. 이때 브라우저는 전체 또는 일부 요소들의 위치나 크기를 다시 계산해서 **렌더 트리(Render Tree)** 를 수정하게 된다.

쉽게 말해, "누가 어디에 어떻게 배치될지" 다시 정하는 작업이라고 볼 수 있다.

> **렌더 트리(Render Tree)란?  
> **  
> 렌더 트리는 브라우저가 HTML과 CSS를 파싱해서 화면에 실제로 보여줄 요소들만 모아 만든 트리 구조이다.  
>   
> DOM 트리 (HTML) + CSSOM 트리 (CSS) → 렌더 트리  
> 화면에 보여질 노드만 포함됨 (예: display: none 요소는 포함되지 않음)  
> 각 노드의 스타일 정보와 레이아웃 정보를 포함하고 있음  
>   
> 즉, 렌더 트리는 “브라우저가 화면에 무엇을 어디에 어떻게 보여줄지“를 결정하기 위한 뼈대이다.  
>   
>   
>  렌더 트리가 중요한 이유  
> \- 리플로우와 리페인트는 모두 렌더 트리를 기반으로 일어난다  
> \- DOM을 조작하거나 스타일을 바꾸면 렌더 트리에 영향을 주게 되고,  
> \-> 리플로우/리페인트가 발생하면서 브라우저 성능 저하로 이어질 수 있다.

---

✏️ **리페인트란 무엇인가?**

리페인트는 요소의 레이아웃은 그대로인데, 시각적 스타일 (색상, 테두리 등) 만 변경되는 경우 발생한다.

대표적으로 background-color, color, border-color, box-shadow 등을 변경하면 리페인트가 발생하며

이 작업은 **화면에 어떻게 보일지**를 다시 그리는 것이지, 위치나 크기를 다시 계산하지는 않는다.

| 항목 | 리플로우 | 리페인트 |
| --- | --- | --- |
| 발생 조건 | 레이아웃(위치, 크기) 변화 | 시각적 스타일 변화 |
| 영향 범위 | 해당 요소 + 하위 요소 전체  | 해당 요소만 |
| 연산 비용 | 높음 (CPU 집중) | 낮음 (GPU 가능) |
| 후속 작업 | 리페인트도 함께 발생 | 리플로우는 아님 |

리플로우는 성능에 더 큰 영향을 주며, 리페인트보다 더 비싼 작업이다.

특히 자주 일어날 경우에는 스크롤이나 에니메이션이 끊기거나 느려질 수 있다고 한다.

---

✏️ **리플로우를 최소화하려면?**

 **최근 Styled-Components**, **Tailwind CSS** 같은 CSS-in-JS 도구나 유틸리티 퍼스트 프레임워크를 많이 사용하는데. 이런 도구들을 사용할 때도 리플로우를 최소화하는 전략은 필요하다.

예를 들어 **Styled-Components를 쓸 때의 리플로우 최적화 팁 이라면**

**1\.** **조건부 스타일은 css 태그 안에서 묶어서 정의하고 한 번에 적용한다.**

```
const Box = styled.div<{ active: boolean }>`
  ${(props) =>
    props.active &&
    css`
      transform: scale(1.1); // 리플로우 없음
      opacity: 1;
    `}
`
```

2\. **조건에 따라 DOM 자체를 여러 번 마운트/언마운트하지 않도록 주의**

→ 조건부 렌더링보다는 스타일 제어로 표현

3\. **중복 스타일 객체 선언 피하기**

→ 같은 스타일을 자주 재사용한다면 styled()나 css()로 모듈화해서 관리